<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Minesweeper</title>

<link rel="stylesheet"
          href="https://fonts.googleapis.com/css?family=Tangerine">
    <style>
      body {
        font-family: 'Tangerine', serif;
        font-size: 25px;
      }
    </style>

    
</head>
<body>

    <div class="c1">
        <h1>Minesweeper</h1>
        <div class="controls">
        <div class="input">
        <label for="mine_count">Number of Mines (5-25):</label>
        <input type="number" id="mine-input" value="5" min="5" max="25">
        </div>
        <button id="str-bttn">Start Game</button>
        </div>
        <div class="status">
            <div>Status: <span id="stat-idictr">Ready</span></div>
            <div> Flags Left: <span id="flag-c">N/A</span></div>
        </div>
        <!-- This is where the game board is going to lay. This is the crux of the gamkds right here.-->
        <div id="grid-c1">
        </div>
    </div>
<script>
    // --- CONSTANTS ---
const GRID_SIZE = 10;

// --- DOM Elements ---
const gridContainer = document.getElementById('grid-c1');
const mineInputElement = document.getElementById('mine-input');
const startButton = document.getElementById('str-bttn');
const statusIndicatorElement = document.getElementById('stat-idictr');
const flagCountElement = document.getElementById('flag-c');

// --- GAME STATE OBJECT ---
let gameState = {
    board: [],
    mineCount: 10,
    flagsPlaced: 0,
    revealedCells: 0,
    status: 'ready', // 'ready', 'playing', 'win', 'loss'
    firstClick: true
};

// --- BOARD MANAGER ---
function initializeBoard() {
    gameState.board = Array.from({ length: GRID_SIZE }, () =>
        Array.from({ length: GRID_SIZE }, () => ({
            isMine: false,
            isRevealed: false,
            isFlagged: false,
            adjacentMines: 0
        }))
    );
}

function placeMines(startRow, startCol) {
    let minesToPlace = gameState.mineCount;
        while (minesToPlace > 0) {
            const r = Math.floor(Math.random() * GRID_SIZE);
            const c = Math.floor(Math.random() * GRID_SIZE);
            if ((r === startRow && c === startCol) || gameState.board[r][c].isMine) continue;
            gameState.board[r][c].isMine = true;
            minesToPlace--;
        }
}

function calculateAdjacentMines() {
    for (let r = 0; r < GRID_SIZE; r++) {
        for (let c = 0; c < GRID_SIZE; c++) {
            if (gameState.board[r][c].isMine) continue;
            let count = 0;
            for (let dr = -1; dr <= 1; dr++) {
                for (let dc = -1; dc <= 1; dc++) {
                    const nr = r + dr;
                    const nc = c + dc;
                    if (nr >= 0 && nr < GRID_SIZE && nc >= 0 && nc < GRID_SIZE && gameState.board[nr][nc].isMine) {
                        count++;
                    }
                }
            }
            gameState.board[r][c].adjacentMines = count;
        }
    }
}

// --- GAME LOGIC ---
function startGame() {
    gameState.mineCount = parseInt(mineInputElement.value);
    gameState.flagsPlaced = 0;
    gameState.revealedCells = 0;
    gameState.status = 'playing';
    gameState.firstClick = true;
    initializeBoard();
    renderBoard();
    updateUI();
}

function revealCell(row, col) {
    if (row < 0 || row >= GRID_SIZE || col < 0 || col >= GRID_SIZE) return;
    const cell = gameState.board[row][col];
    if (cell.isRevealed || cell.isFlagged) return;

    if (cell.isMine) {
        endGame(false);
        return;
    }

        cell.isRevealed = true;
        gameState.revealedCells++;

    if (cell.adjacentMines === 0) {
        for (let dr = -1; dr <= 1; dr++) {
            for (let dc = -1; dc <= 1; dc++) {
                revealCell(row + dr, col + dc);
            }
        }
    }
    checkWinCondition();
}

function toggleFlag(row, col) {
    const cell = gameState.board[row][col];
    if (cell.isRevealed) return;
    if (cell.isFlagged) {
        cell.isFlagged = false;
        gameState.flagsPlaced--;
    } else if (gameState.flagsPlaced < gameState.mineCount) {
        cell.isFlagged = true;
        gameState.flagsPlaced++;
    }
}

function checkWinCondition() {
    const nonMineCells = (GRID_SIZE * GRID_SIZE) - gameState.mineCount;
    if (gameState.revealedCells === nonMineCells) {
        endGame(true);
    }
}

function endGame(isWin) {
    gameState.status = isWin ? 'win' : 'loss';
        gameState.board.forEach(row => row.forEach(cell => {
            if (cell.isMine) cell.isRevealed = true;
        }));
    updateUI();
}

// Checks for the move being inside the grid
function isValid(row, col) {
    return (row >= 0) && (col >= 0) && (row < GRID_SIZE) && (col < GRID_SIZE);
}

// --- USER INTERFACE ---
function renderBoard() {
    gridContainer.innerHTML = '';
    gridContainer.style.gridTemplateColumns = `30px repeat(${GRID_SIZE}, 1fr)`;
    gridContainer.style.gridTemplateRows = `30px repeat(${GRID_SIZE}, 1fr)`;

    gridContainer.appendChild(document.createElement('div'));
    for (let i = 0; i < GRID_SIZE; i++) {
        const label = document.createElement('div');
        label.className = 'grid-label';
        label.textContent = String.fromCharCode(65 + i);
        gridContainer.appendChild(label);
    }

    for (let r = 0; r < GRID_SIZE; r++) {
        const label = document.createElement('div');
        label.className = 'grid-label';
        label.textContent = r + 1;
        gridContainer.appendChild(label);
        for (let c = 0; c < GRID_SIZE; c++) {
            const cellElement = document.createElement('div');
            cellElement.className = 'cell';
            cellElement.dataset.row = r;
            cellElement.dataset.col = c;
            cellElement.innerHTML = `<div class="cell-content"></div>`;
            gridContainer.appendChild(cellElement);
        }
    }
}

function updateBoardUI() {
    for (let r = 0; r < GRID_SIZE; r++) {
        for (let c = 0; c < GRID_SIZE; c++) {
            const cell = gameState.board[r][c];
            const cellElement = document.querySelector(`.cell[data-row='${r}'][data-col='${c}']`);
            const cellContent = cellElement.firstChild;
            
            cellElement.className = 'cell';
            cellContent.textContent = '';
            cellContent.className = 'cell-content';

            if (cell.isFlagged) {
                cellElement.classList.add('flagged');
                cellContent.textContent = 'ðŸš©';
            } else if (cell.isRevealed) {
                cellElement.classList.add('revealed');
                if (cell.isMine) {
                    cellElement.classList.add('mine');
                    cellContent.textContent = 'ðŸ’£';
                } else if (cell.adjacentMines > 0) {
                    cellContent.textContent = cell.adjacentMines;
                    cellContent.classList.add(`c${cell.adjacentMines}`);
                }
            }
        }
    }
}

function updateUI() { //Updating UI for according to requirement spec
    flagCountElement.textContent = gameState.mineCount - gameState.flagsPlaced;
    const statusSpan = statusIndicatorElement;
    statusSpan.className = ''; // Reset classes
    switch (gameState.status) {
        case 'playing':
            statusSpan.textContent = 'Playing';
            statusSpan.classList.add('status-playing');
            break;
        case 'win':
            statusSpan.textContent = 'Victory! ðŸŽ‰';
            statusSpan.classList.add('status-win');
            break;
        case 'loss':
            statusSpan.textContent = 'Game Over: Loss';
            statusSpan.classList.add('status-loss');
            break;
        default:
            statusSpan.textContent = 'Ready';
    }
    updateBoardUI();
}

// --- INPUT HANDLER ---
function handleCellClick(event) {
    const cellElement = event.target.closest('.cell');
    if (!cellElement || gameState.status !== 'playing') return;
    const row = parseInt(cellElement.dataset.row);
    const col = parseInt(cellElement.dataset.col);

    if (gameState.firstClick) {
        gameState.firstClick = false;
            placeMines(row, col);
            calculateAdjacentMines();
    }
    revealCell(row, col);
    updateUI();
}

function handleCellRightClick(event) {
    event.preventDefault();
    const cellElement = event.target.closest('.cell');
    if (!cellElement || gameState.status !== 'playing') return;
    const row = parseInt(cellElement.dataset.row);
    const col = parseInt(cellElement.dataset.col);
    toggleFlag(row, col);
    updateUI();
}

// --- INITIALIZATION ---
startButton.addEventListener('click', startGame);
gridContainer.addEventListener('click', handleCellClick);
gridContainer.addEventListener('contextmenu', handleCellRightClick);
startGame();
</script>
</body>
</html>

